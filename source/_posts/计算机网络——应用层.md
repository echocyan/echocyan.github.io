---
title: 计算机网络——应用层
categories:
  - 学习笔记
  - 计算机网络
tags:
  - 学习
  - 计算机网络
  - 应用层
abbrlink: e1113bf9
date: 2025-11-17 23:07:25
---

# 计算机网络——应用层

## 应用层体系结构

### 客户-服务器模型(C/S)

服务器：提供计算服务的设备。

1、永久提供服务。

2、永久性访问地址/域名。

客户机：请求计算服务的主机。

1、与服务器通信，使用服务器提供的服务。

2、间歇性接入网络。

3、可能使用动态 IP 地址。

4、不与其他客户机直接通信。

### P2P(Peer-to-Peer)模型

不存在永远在线的服务器

每个主机既可以提供服务，也可以请求服务。

任意端系统/结点之间可以直接通讯。

结点间歇性接入网络。

结点可能改变 IP 地址。

可拓展性好，网络健壮性强。

## HTTP 协议

HTTP 协议是一种应用层协议，它规定了参与 Web 通信的浏览器和 Web 服务器之间的通信细节。HTTP 协议主要用于传输超文本网页及其相关网络资源。HTTP 使用 TCP 作为运输协议。

### HTTP 报文格式

#### 请求报文

下面是一个典型的 HTTP 请求报文

```http
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html
Connection: keep-alive

```

##### 请求行

报文的第一行是请求行，也是最核心的一行，由三个字段组成，由空格分开。

1. 方法字段：表明希望服务器要执行的操作，包括 GET、POST、PUT、DELETE、HEAD。
2. URL 字段：指定请求资源的路径，只包含路径部分，不包括域名。
3. HTTP 版本字段：表示使用的 HTTP 协议版本。

##### 首部行

首部行由若干个键值对组成，用来传递附加信息，比如客户端的类型、期望接收的数据格式等。

- `Host`: 必须包含的字段 (在 HTTP/1.1 中)。它指明了请求的目标服务器域名。为什么需要它？因为一台物理服务器上可能托管着多个网站（虚拟主机），服务器需要通过`Host`字段来判断你到底想访问哪个网站。
  - `Host: www.example.com`
- `User-Agent`: “用户代理”，也就是你客户端的身份标识。它告诉服务器你用的是什么浏览器、什么操作系统。服务器可以根据这个信息返回对特定浏览器优化过的内容。
  - `User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36`
- `Accept`: 告诉服务器，我的浏览器能理解哪些类型的内容。
  - `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8` (表示优先接收 HTML，但其他也行)
- `Accept-Language`: 告诉服务器，我偏好哪种语言。
  - `Accept-Language: zh-CN,zh;q=0.9` (首选简体中文)
- `Connection`: 控制 TCP 连接的行为。`keep-alive`表示希望使用我们之前讨论过的持续连接。
  - `Connection: keep-alive`

##### 实体主体

可选的，它包含了你想要提交给服务器的数据。

对于 GET 请求，由于它的目的是从服务器获取数据，所以通常没有实体主体。

#### 响应报文

```http
HTTP/1.1 200 OK
Date: Wed, 18 Apr 2024 12:00:00 GMT
Server: Apache/2.4.1 (Unix)
Last-Modified: Wed, 18 Apr 2024 11:00:00 GMT
Content-Length: 12345
Content-Type: text/html; charset=UTF-8
```

##### 状态行

这是响应报文的第一行，包含了最重要的处理结果信息。

- 版本 : 服务器使用的 HTTP 协议版本，如 HTTP/1.1。
- 状态码: 一个三位数的数字，是响应的核心。它用代码的形式告诉客户端请求的结果是成功、失败还是需要其他操作。
- 原因短语 : 对状态码的一个简短的、人类可读的文字描述，如 OK, Not Found。

状态码被分成了五大类：

- 2xx (成功): 表示请求被成功接收、理解和处理。
  - 200 OK: 最常见的成功状态码。表示请求成功，服务器已返回所请求的数据。
- 3xx (重定向): 表示需要客户端采取进一步的操作才能完成请求。
  - 301 Moved Permanently: 永久重定向。你请求的资源已经永久搬到了一个新的 URL。浏览器会自动跳转到新地址。
  - 302 Found: 临时重定向。
- 4xx (客户端错误): 表示客户端的请求有语法错误或请求无法实现。
  - 400 Bad Request: 请求本身有误，服务器无法理解。
  - 403 Forbidden: 服务器理解请求，但拒绝执行。你没有权限访问。
  - 404 Not Found: 最著名的状态码。服务器上没有找到你请求的资源（网页、图片等）。
- 5xx (服务器错误): 表示服务器在处理请求的过程中发生了内部错误。
  - 500 Internal Server Error: 服务器内部出错了，这是一个通用的服务器错误码。
  - 503 Service Unavailable: 服务器当前暂时无法处理请求（可能过载或正在维护）。

##### 首部行

和请求首部一样，这里也是 键值对的列表，提供了关于响应的附加信息。

- Content-Type: 极其重要。告诉浏览器，我发给你的实体主体是什么格式的。浏览器根据这个值来决定如何解析和展示内容。
  - text/html: 这是 HTML 文档。
  - image/jpeg: 这是 JPG 图片。
  - application/json: 这是 JSON 数据。
  - text/css: 这是 CSS 样式表。
- Content-Length: 告诉浏览器，实体主体的长度是多少字节。浏览器可以用它来判断数据是否接收完整。
- Date: 服务器生成并发送此响应的日期和时间。
- Server: 告诉客户端，处理你这个请求的服务器软件是什么。
  - Server: Apache/2.4.1 (Unix)
  - Server: nginx/1.20.1
- Last-Modified: 请求的这个文件在服务器上最后一次被修改的时间。这个首部主要用于浏览器缓存。
- Set-Cookie: 非常重要。服务器通过这个首部在你的浏览器上设置一个 Cookie。下次你再请求这个网站时，浏览器会自动带上这个 Cookie，让服务器认出你。

##### 实体主体

这就是真正的客户端请求的资源本身。

- 如果请求的是一个 HTML 页面，实体主体就是这个页面的完整 HTML 代码。
- 如果请求的是一张图片，实体主体就是这张图片的二进制数据。

### HTTP 响应的状态码

状态代码由三位数字组成，第⼀个数字定义了响应的类别，共分 5 种类别：

1xx：指示信息——表示请求已接收，继续处理；

2xx：成功——表示请求已被成功接收、理解和接受；

3xx：重定向——要完成请求必须进⾏更进⼀步的操作；

4xx：客户端错误——请求有语法错误或请求⽆法实现；

5xx：服务器端错误——服务器未能实现合法的请求。

### Cookie

是服务器发送到用户浏览器并保存在本地的一小块数据。浏览器会存储 cookie 并在下次向同一服务器再发起请求时携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器——如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。

服务器使用响应首部字段`Set-Cookie`来发送 cookie 信息。

当用户的浏览器第一次访问一个需要状态管理的网站时（比如登录），服务器在处理完你的请求后，会在发回的 HTTP 响应报文中，包含一个特殊的**`Set-Cookie`**首部。

```http
HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: session-id=3a8d4z9b2c7f1; Expires=Wed, 21 Oct 2025 07:28:00 GMT
```

当用户的浏览器收到响应报文后，它会在管理的 cookie 文件中添加收到的 cookie 信息。

当用户再次访问这个网站时，会自动在请求报文的首部中添加一个`Cookie`字段

```http
GET /cart.html HTTP/1.1
Host: www.example-store.com
Cookie: session-id=3a8d4z9b2c7f1
```

当服务器收到含有 Cookie 首部的请求后，会去数据库中查找这个 Cookie 信息，从而恢复之前的信息，比如登录信息等。

![用cookie跟踪用户状态](https://image.echocyan.top/20251117224916556.webp)

## DNS

**DNS**（域名系统，Domain Name System）将人类易于记忆的域名（例如 mozilla.org）翻译成为数字化的 IP 地址（例如 192.0.2.172）；这一从域名到 IP 地址的映射过程被称为 DNS 查询。与之对应，DNS 反向查询用来找到与 IP 地址对应的域名。

## UDP socket 实验

《计算机网络：自顶向下方法》(第 8 版)一书中的一个 socket 编程实验，实验任务如下：

1. 客户从其键盘读取一行字符（数据）并将该数据向服务器发送

2. 服务器接受该数据并将这些字符转换为大写

3. 服务器将修改的数据发送给客户

4. 客户接收修改的数据并在其监视器上将该行显示出来

### `UDPClinet.py`

```python
import socket

# 服务器 IP 地址
serverName = '127.0.0.1'
# 服务器端口号
serverPort = 12000

# 创建UDP socket
clientSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# 获取用户输入
message = input('Input lowercase sentence:')

# 将字符串编码为字节并发送给服务器
clientSocket.sendto(message.encode(), (serverName, serverPort))

# 从服务器接受返回的数据
modifiedMessage, serverAddress = clientSocket.recvfrom(2048)

print(modifiedMessage.decode())

clientSocket.close()
```

### `UDPServer.py`

```python
import socket

# 服务器端口号
serverPort = 12000
# 这里我们不指定IP地址，而是使用空字符串，表示服务器可以在任何可用的网络接口上接收连接
serverName = ''

# 创建UDP socket
# AF_INET 表示使用IPv4，SOCK_DGRAM 表示这是一个UDP socket
serverSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# 将 socket 绑定到指定的端口
serverSocket.bind((serverName, serverPort))

print("The server is ready to receive")

# 进入一个无限循环，持续等待并处理客户端发送的请求
while True:
    # recvfrom 会阻塞程序，直到收到一个数据报
    # 2048 是缓冲区大小，表示一次最多能接收 2048 字节的数据
    # 它返回两个值：数据本身(message)和客户端的地址(clientAddress)
    message, clientAddress = serverSocket.recvfrom(2048)

    # 将接收到的数据解码为字符串
    decoded_message = message.decode()

    # 将字符串转换为大写
    modifiedMessage = decoded_message.upper()

    # 将修改后的字符串编码为字节，并发送回客户端
    serverSocket.sendto(modifiedMessage.encode(), clientAddress)

    print('send success')
```

![程序运行截图](https://image.echocyan.top/20251117231426940.webp)
